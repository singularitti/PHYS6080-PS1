\section{3}

Here you are to investigate back recursion to determine the modified Bessel function
$I_n(x)$.

The sample code below uses back recursion to calculate $I_n(x)$, denoted by \texttt{i} in
the code. These values can be compared with the values determined by Python, denoted by
\texttt{iex}. For $x$ in the range $1$ to $10$, how many back recursion steps are needed to
determine $I_0(x)$ to $I_5(x)$ to $6$ decimal places of accuracy? The normalization of the
$I$'s from back recursion is not included in the code below.

This code also uses the \texttt{Decimal} module to allow you to do back recursion to many
decimal places of accuracy. Suppose for some reason you need the modified Bessel functions
$I_0(x)$ to $I_5(x)$ accurate to $24$ decimal places for $x$ in the range $1$ to $10$.  How
many back recursion steps do you need to achieve this?

\begin{minted}[frame=single]{python}
#  Back recursion for modified Bessel fucntions using decimal
from scipy import special
from decimal import *

getcontext().prec = 50

ord = 30
x = 5
xd = Decimal(int(x))

id = np.arange(Decimal("0.0"), Decimal(int(ord)), Decimal("1.0"))
id[-1] = Decimal("1.0")
id[-2] = Decimal("0.0")

i = np.zeros(ord)
iex = np.zeros(ord)

i[ord - 1] = 1
i[ord - 2] = 0

iex[ord - 1] = special.iv(ord - 1, x)
iex[ord - 2] = special.iv(ord - 2, x)

for n in np.arange(ord - 2, 0, -1):

    #  i[n+1] = -2 * n * i[n]/x + i[n-1]

    i[n - 1] = i[n + 1] + 2 * n * i[n] / x
    iex[n - 1] = special.iv(n - 1, x)

for nd in np.arange(Decimal(int(ord - 2)), Decimal("0"), Decimal("-1")):

    #  i[n+1] = -2 * n * i[n]/x + i[n-1]

    n = int(nd)

    id[n - 1] = id[n + 1] + Decimal("2") * nd * id[n] / xd

plt.plot(np.divide(i[0:10], iex[0:10]))
\end{minted}
