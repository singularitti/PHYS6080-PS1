\section{Problem \thesection}

Here you are to investigate back recursion to determine the modified Bessel function
$I_n(x)$.

\Question Write a program using back recursion to calculate $I_n(x)$.
Their values can be compared with the values determined by SciPy.
For $x$ in the range $1$ to $10$, how many back recursion steps are needed to
determine $I_0(x)$ to $I_5(x)$ to $6$ decimal places of accuracy?

\Answer First, we need to write a little program for the modified Bessel functions.
Since the \emph{normalizer} is
%
\begin{equation}\label{eq:normalize}
    1 = I_0(x) - 2 I_2(x) + 2 I_4(x) - 2 I_6(x) + \ldots,
\end{equation}
%
we need to write a little code, as shown in Snippet \ref{lst:normalize}.
The \texttt{coeff} function calculates each coefficient of the
modified Bessel functions: $\bm{c} = \irow{1 & 0 & -2 & 0 & 2 & -2 & 0 & 2 & \ldots}$.
And in function \texttt{normalize} we divide each order of the modified Bessel function
by a scaling factor, which is determined by the normalizer \eqref{eq:normalize}.

\begin{algorithm}
    \caption{Normalization algorithm for a series of modified Bessel functions.}
    \label{lst:normalize}
    \begin{pythoncode}
        import numpy as np


        def coeff(i):
            if i == 0:
                return 1
            elif i % 4 == 0:
                return 2
            elif i % 2 == 0:
                return -2
            else:
                return 0


        def normalize(I):
            coeffs = np.vectorize(coeff)(range(len(I)))
            scaling_factor = np.dot(coeffs, I)  # Return $\sum_i \bm{c}_i \bm{I}_i(x)$
            return I / scaling_factor  # Divide all values in $\bm{I}$ by the `scaling_factor`
    \end{pythoncode}
\end{algorithm}

Now we can write our back recursion algorithm, as shown in Snippet \ref{lst:back_recursion}.
In function \texttt{back\_recursion}, we first initialize an empty vector \texttt{I} which
will store the values of the modified Bessel functions of each order up to
\texttt{max\_order} ($30$ in this example) at $x$, i.e., $I_n(x)$, where
$n = 1, 2, \ldots, 30$.
Then we set the last two values of \texttt{I} to be anything we want, $1$ and $0$ here,
since $I_n(x)$ at fixed $x$ decreases with increasing $n$.
And we work back to the first order using the recurrence relation:
%
\begin{equation}
    I_{n + 1}(x) = -\frac{ 2 n }{ x } I_n(x) + I_{n - 1}(x).
\end{equation}
%
At last, we normalize the series with normalizer \eqref{eq:normalize}.

\begin{algorithm}
    \caption{A na√Øve back recursion algorithm.}
    \label{lst:back_recursion}
    \begin{pythoncode}
        def back_recursion(x, last_order):
            orders = range(last_order + 1)
            I = np.empty(last_order + 1)  # Orders from 0 to `last_order`
            I[-2:] = 1, 0  # Set the last two values
            for n in np.flip(orders)[2:]:  # Orders from `last_order-2` to 0
                I[n] = I[n + 2] + 2 * (n + 1) / x * I[n + 1]
            return normalize(I)
    \end{pythoncode}
\end{algorithm}

\Question This code also uses the \texttt{Decimal} module to allow you to do back recursion to many
decimal places of accuracy. Suppose for some reason you need the modified Bessel functions
$I_0(x)$ to $I_5(x)$ accurate to $24$ decimal places for $x$ in the range $1$ to $10$. How
many back recursion steps do you need to achieve this?

\begin{minted}{python}
def back_recursion_precise(x, last_order):
    orders = range(last_order + 1)
    I = np.fromiter(map(Decimal, orders), Decimal)
    I[-2:] = Decimal(1), Decimal(0)
    for n in np.flip(orders)[2:]:  # Orders from `last_order-2` to 0
        I[n] = I[n + 2] + 2 * (n + 1) / Decimal(x) * I[n + 1]
    return normalize(I)
\end{minted}
