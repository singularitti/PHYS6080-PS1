\section{Problem \thesection}\label{sec:p1}

Here, we will look at the propagation of finite precision errors in
multiplication. We start by truncating the input numbers to a fixed precision, given by
\code{ndig}, and compare this to the result without truncating. To keep things relatively simple,
we start from random numbers distributed uniformly between $0$ and $1$. We then shift these,
to keep the result from getting either too large or too small.

In Snippet \ref{lst:round}, to round a floating point number $x$, it is first decomposed by
\code{math.frexp(x)} and the mantissa is rounded to a desired number of digits. Then the
rounded mantissa is multiplied by the exponent to give a rounded version of the floating
point number.

\begin{algorithm}
    \caption{Rounding a floating point number to a certain number of digits.}
    \label{lst:round}
    \begin{pythoncode}
        import math


        def myround(x, ndigits):
            mantissa, exponent = math.frexp(x)
            return round(mantissa, ndigits) * 2**exponent
    \end{pythoncode}
\end{algorithm}

We can also write a similar \code{truncate} function to discard the rest of the digits
in $x$, as shown in Snippet \ref{lst:truncate}.

\begin{algorithm}
    \caption{Truncating a floating point number to a certain number of digits.}
    \label{lst:truncate}
    \begin{pythoncode}
        def truncate(x, ndigits):
            return int(x * 10**ndigits) * 10**(-ndigits)
    \end{pythoncode}
\end{algorithm}

To see how finite precision errors propagates in multiplication, we need first define the
rounded and truncated versions of multiplication, as in Snippet \ref{lst:multiply}:

\begin{algorithm}
    \caption{Rounded and truncated versions of multiplication of floating point numbers.}
    \label{lst:multiply}
    \begin{pythoncode}
        def rounded_mul(x, y, ndigits):
            x, y = myround(x, ndigits), myround(y, ndigits)
            return x * y
        
        
        def truncated_mul(x, y, ndigits):
            return x * truncate(y, ndigits)
    \end{pythoncode}
\end{algorithm}

Then we can define the accumulated results of $x$ times $y$, as shown in Snippet
\ref{lst:accumulate}.

\begin{algorithm}
    \caption{Rounded and truncated versions of multiplication of floating point numbers.}
    \label{lst:accumulate}
    \begin{pythoncode}
        from functools import partial, reduce


        def rounded_accumulate(ys, ndigits, initial):
            func = partial(rounded_mul, ndigits=ndigits)
            return reduce(func, ys, initial)
        
        
        def truncated_accumulate(ys, ndigits, initial):
            func = partial(truncated_mul, ndigits=ndigits)
            return reduce(func, ys, truncate(initial, ndigits))
    \end{pythoncode}
\end{algorithm}

Notice how the deviation for the truncated case is growing $10$ times worse with every $10$
times increase in floating point operations:

\begin{algorithm}
    \caption{An example}
    \label{lst:compare}
    \begin{pythoncode}
        from operator import mul
        import pandas as pd
        
        ndigits = 6  # The number of digits we truncate the operand to
        x = np.random.rand()
        ys = np.random.rand(10000) + 0.542
        colnames = ['n', "type", "full", "rounded", "truncated"]
        df = pd.DataFrame(data=[[0, "value", x, myround(x, ndigits), truncate(x, ndigits)]],
                          columns=colnames)
        for n in (10, 100, 1000, 10000):
            a = reduce(mul, ys[:n], x)
            b = rounded_accumulate(ys[:n], ndigits, x)
            c = truncated_accumulate(ys[:n], ndigits, truncate(x, ndigits))
            diff = 1 - [a, b, c] / a
            new = pd.DataFrame(
                data=[[n, "value", a, b, c], [n, "diff", *diff]], columns=colnames)
            df = pd.concat([df, new])
        df = df.set_index(['n', "type"])
    \end{pythoncode}
\end{algorithm}

\begin{table}[H]
    \centering
    \caption{An example}
    \label{tab:compare}
    \begin{tabular}{@{}ccccc@{}}
        \toprule
        $n$                      & type  & full            & rounded         & truncated       \\
        \midrule
        $0$                      & value & $0.96056312$    & $0.96056300$    & $0.96056300$    \\
        \cmidrule{1-2}
        \multirow{2}{*}{$10$}    & value & $0.36782129$    & $0.36782242$    & $0.36781875$    \\
                                 & diff  & $0$             & $-0.00000309$   & $0.00000691$    \\
        \cmidrule{1-2}
        \multirow{2}{*}{$100$}   & value & $1.98537614$    & $1.98539378$    & $1.98526658$    \\
                                 & diff  & $0$             & $-0.00000889$   & $0.00005518$    \\
        \cmidrule{1-2}
        \multirow{2}{*}{$1000$}  & value & $49.15195379$   & $49.15357717$   & $49.12509557$   \\
                                 & diff  & $0$             & $-0.00003303$   & $0.00054643$    \\
        \cmidrule{1-2}
        \multirow{2}{*}{$10000$} & value & $7540.39925532$ & $7540.87648179$ & $7500.67631548$ \\
                                 & diff  & $0$             & $-0.00006329$   & $0.00526802$    \\
        \bottomrule
    \end{tabular}
\end{table}

\Question For this problem, you should start from this code and adapt it to be run many times in a
loop (hundreds of times). For each time through the loop, you should store the fractional
differences for both rounding and truncation after $100$, $1000$ and $10000$ multiplications.
Plot a histogram of the deviations for both cases and the three different numbers of
multiplications. Plot the average difference versus the number of multiplies for both the
rounding and truncation cases to see how it scales with the number of multiplies.
